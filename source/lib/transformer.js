const transform = (lines, transforms, result = []) => {
    if (!lines.length) return result

    const [currentLine] = lines

    const matchingTransformation = transforms.find(([regexp]) => regexp.test(currentLine))

    if (matchingTransformation) {
        const [regexp, replacer] = matchingTransformation
        const transformedLine = currentLine.replace(regexp, replacer)

        const matchingIndex = transforms.findIndex(x => x === matchingTransformation)

        // Alacritty uses the same color name for bright and normal colors. So you
        // will find for example Yellow ...

        // Yellow ... <-- same name! This is a problem because they both refer to
        // different colors. So teems needs to use for example color3 for the first
        // Yellow but color11 for the second.

        // The way this is currently done is by creating two transforms that both
        // match exactly the same line but then replace it with something different.
        // Whenever any transform is used, it is removed from the remaining
        // transforms. This only works if the colors occur in the config in the same
        // order as the transforms are added to the makeTransforms methods return
        // array. In other words, if you added the transform for a bright color
        // first (to the transforms array) it would replace the normal color with
        // the bright one. Next time Yellow is matched, the normal color will then
        // be used, even though the bright one was necessary.

        // To keep things generic, this architecture is used for all apps. Xresource
        // for example has color0 through color15. I wrote a generic matcher that
        // captures the number in a capture group. Because we are now removing
        // transforms once they are used we need 16 such transforms. They are
        // autogenerated through Array(16).fill(..).

        // Whenever a transform was used, its index is retrieved and then the
        // remaining transforms are generated through: keep all but the one with the
        // index we just used.
        return transform(
            lines.slice(1),
            transforms.filter((_, i) => i !== matchingIndex),
            result.length ? result.concat([transformedLine]) : [transformedLine]
        )
    }

    return transform(
        lines.slice(1),
        transforms,
        result.length ? result.concat([currentLine]) : [currentLine]
    )
}

module.exports = transform
